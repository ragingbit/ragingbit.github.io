<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[ragingbit | blog]]></title><description><![CDATA[Thoughts, ideas and articles in the development and food spaces]]></description><link>https://ragingbit.github.io/</link><image><url>https://ragingbit.github.io/favicon.png</url><title>ragingbit | blog</title><link>https://ragingbit.github.io/</link></image><generator>Ghost 5.94</generator><lastBuildDate>Sun, 13 Oct 2024 17:47:53 GMT</lastBuildDate><atom:link href="https://ragingbit.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Pull request templates]]></title><description><![CDATA[Use templates to set a standard for developers and collaborators to follow, making it easy to create easy-to-read pull requests.]]></description><link>https://ragingbit.github.io/pull-request-templates/</link><guid isPermaLink="false">66fe701f5be3850001a800ec</guid><category><![CDATA[Collaboration]]></category><category><![CDATA[Git]]></category><category><![CDATA[Quality]]></category><category><![CDATA[Conventions]]></category><dc:creator><![CDATA[Johannes Steen]]></dc:creator><pubDate>Sun, 13 Oct 2024 17:20:51 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1471666875520-c75081f42081?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDN8fHRlbXBsYXRlfGVufDB8fHx8MTcyNzk1MjY0N3ww&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1471666875520-c75081f42081?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDN8fHRlbXBsYXRlfGVufDB8fHx8MTcyNzk1MjY0N3ww&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000" alt="Pull request templates"><p>In GitHub, we can use templates in an effort to codify and standardise pull requests. Getting started is as simple as putting a <code>PULL_REQUEST_TEMPLATE.md</code> file in the <code>.github</code> folder of your repo.</p><p>To support and encourage being a good pull request writer, provide space for descriptions, hints on how to write good context and explanations, what details to always or optionally include, etc.</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://ragingbit.github.io/writing-better-pull-requests/"><div class="kg-bookmark-content"><div class="kg-bookmark-title">Writing better pull requests</div><div class="kg-bookmark-description">In order to maintain a high level of standard as well as high level of confidence in the things we develop, peer reviewing pull requests is an invaluable aid. Together with other tools like linters, unit tests, static code analysis and more, it provides a way for peers to review</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://ragingbit.github.io/content/images/icon/favicon.ico" alt="Pull request templates"><span class="kg-bookmark-author">ragingbit | blog</span><span class="kg-bookmark-publisher">Johannes Steen</span></div></div><div class="kg-bookmark-thumbnail"><img src="https://ragingbit.github.io/content/images/thumbnail/photo-1505682634904-d7c8d95cdc50" alt="Pull request templates" onerror="this.style.display = &apos;none&apos;"></div></a></figure><p>The template can contain checklists of items to do before creating a pull request, e.g. making sure tests are written, code style is followed, formatting is done, outcomes are matched, documentation is added, etc.</p><pre><code class="language-markdown">## Description

&lt;!--
Fill in a succinct context and description to
help reviewers understand the requested change:

Example: This PR will add/fix/remove/update the
feature/bug
--&gt;

## Related issues

&lt;!--
Reference any issue or document that&apos;s related
to the pull request being made.

Example: Implements/Fixes #123
--&gt;

## How to verify

&lt;!--
Provide steps to verify the feature or fix.

Example: Check by calling the /api/v2/restart-car
endpoint. Result should be a HTTP 206.
--&gt;

## Checklist

[ ] - Code style
[ ] - Tests
[ ] - Documentation

## Optional information

&lt;!--
Any additional information that may be of use: what
the weather was like, interesting gifs, meme of the
week.
--&gt;</code></pre><h2 id="controversially-allow-the-description-and-conversation-to-be-playful-when-appropriate">Controversially, allow the description and conversation to be playful when appropriate</h2><p>As much as I&apos;m usually striving to be completely factual, minimalist and to the point, there is a case to be made for using emotes, icons and gifs to sprinkle the pull request experience with engaging expressions. It can help bridge language gaps, aid in letting people express themselves and their personality, and make the review process more enjoyable - so let people use &apos;em! Encourage it by including some in your template, for instance sprinkling categories and lists with icons and emotes.</p>]]></content:encoded></item><item><title><![CDATA[Writing better pull requests]]></title><description><![CDATA[Creating pull requests is easy - writing them to be legible and easy to understand can be an art.]]></description><link>https://ragingbit.github.io/writing-better-pull-requests/</link><guid isPermaLink="false">66cf45432c0b3600013b7e11</guid><category><![CDATA[Collaboration]]></category><category><![CDATA[Conventions]]></category><category><![CDATA[Git]]></category><category><![CDATA[Quality]]></category><dc:creator><![CDATA[Johannes Steen]]></dc:creator><pubDate>Thu, 03 Oct 2024 10:23:30 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1505682634904-d7c8d95cdc50?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDM4fHx3cml0aW5nJTIwY29kZXxlbnwwfHx8fDE3Mjc4MDE2MjJ8MA&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1505682634904-d7c8d95cdc50?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDM4fHx3cml0aW5nJTIwY29kZXxlbnwwfHx8fDE3Mjc4MDE2MjJ8MA&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000" alt="Writing better pull requests"><p>In order to maintain a high level of standard as well as high level of confidence in the things we develop, peer reviewing pull requests is an invaluable aid. Together with other tools like linters, unit tests, static code analysis and more, it provides a way for peers to review the code or config that we write for inconsistencies, errors or to make suggestions for improvement.</p><p>To help keep this process smooth and efficient, there are ways to tailor your pull requests to be easier to read and review, as well as ways you can be a better reviewer.</p><h2 id="prefer-consistent-branch-names">Prefer consistent branch names</h2><p>Having consistent branch names with standardised prefixes and issue numbering:</p><ul><li>Helps discoverability</li><li>Allows automatic tagging or categorisation of pull requests</li><li>Allows automatic linking of pull requests to issues</li></ul><h2 id="keep-it-short">Keep it short</h2><p>To make pull requests easier and more quick to review and merge, try to keep them short. Stay on point to the task at hand. If the task is large or has multiple contexts, separate your work into multiple, logical pull requests to focus those contexts. Don&#x2019;t fix or change things not related to the task - create other pull requests for that.</p><h2 id="rebase-onto-the-target-branch-before-creating-the-pr">Rebase onto the target branch before creating the PR</h2><p>Rebasing and having an up to date feature/fix branch before creating your PR will save you and your reviewers the time of doing it after the PR has been created. Rebases are preferred to merges to reduce the complexity of reviewing changes in detail. Your feature/fix branch will contain only your relevant commits.</p><ul><li>It ensures that tests are against the latest code and will pass when the code is merged</li><li>It ensures that you don&#x2019;t have to rewrite a feature after the PR is created simply because someone else introduced a change before you</li></ul><h2 id="describe-the-change">Describe the change</h2><p>Pull request titles and descriptions give the peer reviewing your pull request some initial context on the feature or fix being merged. Make that title and description easy to read and easily scannable.</p><h3 id="details-up-front">Details up front</h3><p>Including the following details can drastically improve the speed with which a pull request is reviewed:</p><ul><li>Brief title with clear intent of the change being proposed</li><li>A link to the issue, preferably through automation if detected in the branch name</li><li>A summary of what&#x2019;s been done that expands on the title of the PR, listing the specific changes<ul><li>Providing clear, consistent commit summaries can help create this list quickly and efficiently</li></ul></li><li>Links to related pull requests in other repositories if part of the same change</li></ul><h3 id="use-plain-language">Use plain language</h3><p>Simpler words always convey meaning faster, normal words are preferable to jargon:</p><ul><li>Prefer &#x201C;<em>use</em>&#x201D; to &#x201C;<em>utilise</em>&#x201D; - different meanings and you probably want the meaning of &#x201C;<em>use</em>&#x201D;</li><li>Prefer &#x201C;<em>request</em>&#x201D; to &#x201C;<em>ask</em>&#x201D; - ask is a verb, not a noun (&#x201C;<em>what&#x2019;s the ask?</em>&#x201D; vs &#x201C;<em>what&#x2019;s the request?</em>&#x201D;)</li><li>Prefer &#x201C;<em>do</em>&#x201D; to &#x201C;<em>operationalise</em>&#x201D; - 12 fewer letters, 5 fewer syllables</li></ul><h3 id="avoid-passive-voice">Avoid passive voice</h3><p>Passive voice is often used when discussing things perceived negatively, such as bugs, downtime, crashes and the like. It&#x2019;s a sign of people wanting to avoid assigning blame, or dodging blame (even when there&#x2019;s no blame to assign or dodge):</p><p>&#x201C;<em>We were asked to fix the algorithm that caused this bug by the customer services team.</em>&#x201D;</p><p>A rewrite of this is easy, removing passive tones and promoting a direct voice:</p><p>&#x201C;<em>The customer services team asked us to fix the algorithm that caused this bug.</em>&#x201D;</p><p> Be direct when writing about your code without necessarily throwing people under the bus.</p><h3 id="avoid-adverbs">Avoid adverbs</h3><p>Adverbs can often be removed to make your descriptions more terse:</p><p>&#x201C;<em>Replace a <strong>really slowly</strong> performing Qlik query with a faster raw SQL query</em>&#x201D; vs &#x201C;<em>Replace a slow Qlik query with a faster raw SQL query</em>&#x201D;. That we&#x2019;re doing it for the sake of improving performance is implicitly understood.</p><h3 id="keep-it-simple">Keep it simple</h3><p>Avoid making your sentences and paragraphs bloated with extraneous details and wording. For example:</p><p>&#x201C;<em>The reason this is marked as DRAFT is to wait for the final verification of the name of the feature flag for the new login path.&#x201D;</em></p><p>&#x201C;The reason this is&#x201D; can be replaced with &#x201C;This is&#x201D;. The &#x201C;is&#x201D; before &#x201C;to wait&#x201D; is unnecessary and can easily be removed. The last part of the sentence can be made more direct by removing prepositions.</p><p>&#x201C;<em>This is marked DRAFT to wait for final verification of the new login path&#x2019;s feature flag name.&#x201D;</em></p><h3 id="putting-it-all-together">Putting it all together</h3><pre><code>If merged, this PR will:
* Add a new model for cars
* Add endpoints for CRUD operations on car properties
* Update policies to only allow admins to rename cars
* Fix error in car naming algorithm

Related issues:
* [Allow custom properties for cars](jira://cars-feature/issue/54)
* [Lack of custom properties causes error in naming of cars](jira://cars-feature/issue/12)

Related PRs:
* [View changes to car reports](git://report-repo/pr/123)</code></pre><h2 id="comment-on-your-own-pull-requests">Comment on your own pull requests</h2><p>Instead of adding long comments in code that might not stand the test of time or simply don&#x2019;t have a place there, add comments in the pull request itself. Explain why you made that refactoring, or removed that piece of code to give context to peers reviewing your request.</p><h2 id="avoid-changing-pushed-commits">Avoid changing pushed commits</h2><p>Try not to amend or squash already pushed commits when making updates to a remote branch. Do create new commits to address issues or comments, making it easier to review. Of course, amending or squashing commits that have not been pushed yet is perfectly viable. In fact, there are useful tools for maintaining a clean history before it&#x2019;s pushed:</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://ragingbit.github.io/collaborating-when-using-git/"><div class="kg-bookmark-content"><div class="kg-bookmark-title">Collaborating when using Git</div><div class="kg-bookmark-description">When collaborating in a team or an open source repository it&#x2019;s important to maintain conventions and standards, to be able to confidently trace changes</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://ragingbit.github.io/content/images/icon/favicon.ico" alt="Writing better pull requests"><span class="kg-bookmark-author">ragingbit | blog</span><span class="kg-bookmark-publisher">Johannes Steen</span></div></div><div class="kg-bookmark-thumbnail"><img src="https://ragingbit.github.io/content/images/thumbnail/photo-1556075798-4825dfaaf498" alt="Writing better pull requests" onerror="this.style.display = &apos;none&apos;"></div></a></figure><h2 id="be-active-and-respond-quickly">Be active and respond quickly</h2><p>Keep the life-time of a pull request shorter by responding to simple comments quickly, fixing typos or renaming things for clarity, or even adding unit tests where missed.</p><p>Don&#x2019;t forget to thank reviewers for their time!</p>]]></content:encoded></item><item><title><![CDATA[Technical debt]]></title><description><![CDATA[How to identity what actually is a technical debt is crucial in order to prioritise time and resources.]]></description><link>https://ragingbit.github.io/technical-debt/</link><guid isPermaLink="false">66f508dd4c61da0001248074</guid><category><![CDATA[Maintainability]]></category><dc:creator><![CDATA[Johannes Steen]]></dc:creator><pubDate>Thu, 26 Sep 2024 11:29:20 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1504639725590-34d0984388bd?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDEwN3x8dGVjaHxlbnwwfHx8fDE3MjczMzU1NjF8MA&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<blockquote>In software-intensive systems, technical debt is a collection of design or implementation constructs that are expedient in the short term, but set up a technical context that can make future changes more costly or impossible. Technical debt presents an actual or contingent liability whose impact is limited to internal system qualities, primarily maintainability and evolvability.<em> <br><br>&#x201C;Managing Technical Debt in Software Engineering&#x201D; conference in Dagstuhl, 2016</em></blockquote><img src="https://images.unsplash.com/photo-1504639725590-34d0984388bd?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDEwN3x8dGVjaHxlbnwwfHx8fDE3MjczMzU1NjF8MA&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000" alt="Technical debt"><p>To be able to identify issues of technical debt, it&#x2019;s important to look at the causes of why technical debt is created. The <a href="https://en.wikipedia.org/wiki/Technical_debt">wikipedia page for technical debt</a> contains a helpful and exhaustive list of causes of technical debt that can assist in identifying these items and correctly prioritise both in terms of time and resource spending.</p><p>In summary, some of the most common examples of reason for technical debt stems from e.g. decisions to favour short-term solutions and delay long-term solutions or maintenance:</p><ul><li>updating technologies and patterns</li><li>removing a feature toggle after the feature becomes the default</li><li>refining or even removing a Minimum Viable Product or Proof of Concept</li><li>housekeeping activities<ul><li>updating dependencies, libraries, packages</li><li>code cleanup for readability</li><li>improving tests and test coverage</li><li>refactoring for increased maintainability</li></ul></li></ul><p>The following are examples of things that are not considered tech debt but where ignoring them could certainly lead to increasing technical debt:</p><ul><li>staying current with versions of external products such as partner systems, integrations or operating systems</li><li>dealing with new technical requirements<ul><li>increased security</li><li>lower cost</li><li>increased scale</li><li>improved performance</li></ul></li><li>code defects</li><li>inadequate documentation</li></ul>]]></content:encoded></item><item><title><![CDATA[Taking breaks is important]]></title><description><![CDATA[Regular pauses, longer breaks, and extended vacations is crucial for mental health and overall well-being.]]></description><link>https://ragingbit.github.io/taking-breaks-is-important/</link><guid isPermaLink="false">66cf45432c0b3600013b7e0b</guid><category><![CDATA[Mental health]]></category><dc:creator><![CDATA[Johannes Steen]]></dc:creator><pubDate>Sat, 30 Mar 2024 11:48:01 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1704159498384-8566c54bfbad?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8YWxsfDEzfHx8fHx8Mnx8MTcxMTc5ODMwNHw&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1704159498384-8566c54bfbad?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8YWxsfDEzfHx8fHx8Mnx8MTcxMTc5ODMwNHw&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000" alt="Taking breaks is important"><p>As a software engineer, it&apos;s easy to get caught up in the flow of writing code, designing algorithms and pushing toward deadlines. The tech industry is notorious for its fast-paced environment and high expectations, often leading engineers to work long hours without taking proper breaks. However, prioritising constant work over rest can lead to burnout, decreased productivity, and ultimately, detrimental effects on mental health.</p><h2 id="the-power-of-small-breaks">The power of small breaks</h2><p>It&apos;s common to immerse oneself in solving complex problems for hours on end. While this level of focus can be beneficial, it&apos;s equally important to recognise the value of regular breaks. Studies have shown that taking short breaks throughout the workday can enhance productivity, creativity, and not least of all overall well-being.</p><p>For software engineers, incorporating small breaks into your routine can mean looking away from the computer screen, stretching, or taking a few minutes to relax and clear the mind. These pauses not only prevent mental fatigue but also allow for moments of insight and inspiration.</p><h2 id="the-significance-of-bigger-breaks">The significance of bigger breaks</h2><p>Beyond the daily grind, engineers should also prioritise taking bigger breaks - whether it&apos;s actually taking a lunch break, an afternoon coffee break with colleagues, a midday workout session or going for a short walk. These extended pauses provide an opportunity to recharge both mentally and physically and perhaps some time to think, get perspective on challenges, or simply allow you time to listen music and breathe.</p><h2 id="embracing-vacation">Embracing vacation</h2><p>In addition to daily and weekly breaks, one should not underestimate the importance of longer personal time off. Whether it&apos;s a week-long getaway or a staycation at home, taking time off from work is essential for recharging and gaining perspective.</p><p>Vacation allows people to disconnect from daily responsibilities, explore new interests, spend time with loved ones - or away from everyone - and return to work with renewed energy. Contrary to the belief that taking time off hinders productivity, research suggests that employees who take regular vacations are more productive, creative, and resilient in the long run.</p><h2 id="work-life-balance-your-life-comes-first">Work-life balance: your life comes first</h2><p>Ultimately, the key to maintaining a healthy work-life balance lies in prioritising one&apos;s well-being over work commitments. While the tech industry often glorifies long hours and relentless dedication, true success lies in recognising that your life outside of work is just as important &#x2013; if not more so &#x2013; than your career.</p><p>By embracing the importance of breaks &#x2013; both small and large &#x2013; software engineers can optimise their performance, foster creativity, and safeguard their mental health. Remember, taking time off isn&apos;t a sign of weakness; it&apos;s a strategic investment in your overall well-being and professional longevity. So, the next time you feel tempted to skip a break in favour of pushing through, remember that a rested mind is a productive mind, and your health should always come first.</p>]]></content:encoded></item><item><title><![CDATA[Exiting early]]></title><description><![CDATA[Keeping code easy to read and understand can be challenging. Exiting early is one of the simplest ways to achieve that.]]></description><link>https://ragingbit.github.io/exiting-early/</link><guid isPermaLink="false">66cf45432c0b3600013b7e15</guid><category><![CDATA[Maintainability]]></category><category><![CDATA[Optimisation]]></category><category><![CDATA[Refactoring]]></category><dc:creator><![CDATA[Johannes Steen]]></dc:creator><pubDate>Sun, 12 Nov 2023 12:04:02 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1487505983481-9aa2d9f9901a?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDM2fHxuZXN0ZWQlMjBjb2RlfGVufDB8fHx8MTY5OTc5MDc3N3ww&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1487505983481-9aa2d9f9901a?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDM2fHxuZXN0ZWQlMjBjb2RlfGVufDB8fHx8MTY5OTc5MDc3N3ww&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000" alt="Exiting early"><p>One of my favourite and relatively simple tips for keeping code readable and maintainable is to exit early. It can lead to reduced nesting, it can improve grouping of logical statements and it just looks neater - all in all, it reduces the cognitive complexity of the code you write.</p><p>Let me show what I mean with this contrived example:</p><pre><code class="language-cs">private int GetWheelCount(Car? car)
{
    if (car is not null)
    {
        if (car.Wheels is not null)
        {
            return cars.Wheels.Length;
        }
        else
        {
            return 0;
        }
    }
    else
    {
        throw new ArgumentNullException(nameof(car));
    }
}</code></pre><p>We can improve this drastically by inverting conditions:</p><pre><code class="language-cs">private int GetWheelCount(Car? car)
{
    if (car is null)
    {
        throw new ArgumentNullException(nameof(car));
    }

    if (car.Wheels is null)
    {
        return 0;
    }

    return cars.Wheels.Length;
}</code></pre><p>This reduces the nesting and puts the guard-statements at the top and as you move down through the code you can clearly see the logical steps needed to arrive at the intended outcome.</p>]]></content:encoded></item><item><title><![CDATA[Collaborating when using Git]]></title><description><![CDATA[When collaborating in a team or an open source repository it's important to maintain conventions and standards, to be able to confidently trace changes]]></description><link>https://ragingbit.github.io/collaborating-when-using-git/</link><guid isPermaLink="false">66cf45432c0b3600013b7e02</guid><category><![CDATA[Collaboration]]></category><category><![CDATA[Git]]></category><category><![CDATA[Conventions]]></category><dc:creator><![CDATA[Johannes Steen]]></dc:creator><pubDate>Mon, 30 Oct 2023 08:48:14 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1556075798-4825dfaaf498?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDF8fGdpdHxlbnwwfHx8fDE2OTg2NTU1NTF8MA&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1556075798-4825dfaaf498?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDF8fGdpdHxlbnwwfHx8fDE2OTg2NTU1NTF8MA&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000" alt="Collaborating when using Git"><p>Git is great. It&apos;s also pretty open-ended in how you can use it. When collaborating in a team or an open repository, if everyone has their own view of how to use Git, we quickly end up with a fractured and inconsistent history of changes.</p><h2 id="branch-names">Branch names</h2><p>When creating a new branch it&apos;s recommended to use consistent branch naming that includes the type of task and the issue number. This allows for automation to pick up information for linking issues with pull requests, or creating versions for new releases. What that naming convention looks like is often particular to a team or OSS project but would probably look something like <code>feature/vp312-crud-endpoints-for-cars</code>.</p><ul><li><code>feature</code>: The prefix before the first slash is generally reserved for the type of task. It can (and probably should) be chosen from a range of standardised categories: feature, fix or chore. Non-trunkbased development also tends to utilise release/tag and hotfix prefixes.</li><li><code>vp312</code>: The issue number, identifying which issue the branch is tied to. Branches should generally only cover one issue.</li><li><code>crud-endpoints-for-cars</code>: A very brief description for humans. </li></ul><h2 id="commits">Commits</h2><p>Do them often. Failing to commit often can result in headaches and pains trying to walk back changes that have become too large.</p><p>Intent is a key factor in writing brief, informative and relevant commit messages. Consider the intent of the commit, what is it that you&#x2019;re accomplishing? Try to avoid &quot;update&quot; or &quot;thing&quot;, or the technical description of what you&#x2019;re doing if it&#x2019;s a feature commit and instead focus on the feature itself: instead of &#x201C;add create-endpoint to car controller&#x201D; a much more descriptive message would be &#x201C;allow cars to be updated via api&#x201D;. This might seem superfluous when squash-merging pull requests but it allows for traceability and clarity in reviewing before the code is merged.</p><p>Try to follow an established standard, or modify one to suit. <a href="https://www.conventionalcommits.org/">Conventional Commits</a> is a style that&#x2019;s easy to learn and form a habit around, with permissive conventions around types, categories and issue-linking. Conventional commits also help create a good summary for pull request change lists. They can be used to good advantage in the merge-commit message for pull requests, helping to categorise and link to issues and releases, as well as automating release notes.</p><h3 id="conventional-commit-examples">Conventional commit examples</h3><pre><code>chore: update postcss for es6</code></pre><ul><li><code>chore</code>: commit type</li><li><code>update postcss for es6</code>: commit description</li></ul><pre><code>feat(cars)!: remove ability to update cars via api</code></pre><ul><li><code>feat</code>: commit type</li><li><code>(cars)</code>: optional scope</li><li><code>!</code>: optional signifier for breaking change</li><li><code>remove ability to update cars via api</code>: commit description</li></ul><pre><code>feat(cars-reports): allow more properties when filtering cars

refs: #vp312</code></pre><ul><li><code>feat</code>: commit type</li><li><code>(cars-reports)</code>: optional scope</li><li><code>allow more properties when filtering cars</code>: commit description</li><li><code>refs: #vp312</code>: optional footer token</li></ul><h2 id="staying-up-to-date">Staying up to date</h2><p>A good habit to form is to rebase your branch onto the target daily (or more often!). If you maintain a branch over a longer period of time, integrating the newest changes from the target branch often helps resolve conflicts quickly, making the final pull request merge easier to prepare.</p><p>Rebasing the branch onto the target is preferable to merging the target into the branch, to maintain a clean history and change tree, also helping to reduce the friction of any merge conflicts down the line and the ability to trace changes.</p><p>Configuring the default behaviour of pulls to use rebasing rather than merging is one way to ensure you don&#x2019;t forget: <code>git config --global pull.rebase true</code></p><p>More here: <a href="https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase">https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase</a></p><h2 id="maintaining-a-clean-local-history">Maintaining a clean (local) history</h2><p>Something that frequently helps when tracing earlier changes in a local feature branch is having a clean and readable commit history that follows a reasonably structured timeline. One way to achieve this is to manually amend earlier commits with interactive rebasing. Bryan Braun writes about <a href="https://www.bryanbraun.com/2019/02/23/editing-a-commit-in-an-interactive-rebase/" rel="noreferrer">editing a commit in an interactive rebase</a>. Another option is to use git fixup and autosquash which allows you to create fixup-commits for earlier (un-pushed) commits and then using <code>git --autosquash</code> to automatically prune your git history, which Andrew Lock writes about in his article about <a href="https://andrewlock.net/smoother-rebases-with-auto-squashing-git-commits/" rel="noreferrer">auto-squashing commits</a>.</p><h2 id="links">Links</h2><ul><li><a href="https://www.conventionalcommits.org/en/v1.0.0/">https://www.conventionalcommits.org/en/v1.0.0/</a></li><li><a href="https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase">https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase</a></li><li><a href="https://www.bryanbraun.com/2019/02/23/editing-a-commit-in-an-interactive-rebase/">https://www.bryanbraun.com/2019/02/23/editing-a-commit-in-an-interactive-rebase/</a></li><li><a href="https://andrewlock.net/smoother-rebases-with-auto-squashing-git-commits/">https://andrewlock.net/smoother-rebases-with-auto-squashing-git-commits/</a></li></ul>]]></content:encoded></item><item><title><![CDATA[Red, Green, Refactor]]></title><description><![CDATA[Using Red-Green-Refactor is a way to ensure that the code we write is the result of the capabilities we ask of it.]]></description><link>https://ragingbit.github.io/red-green-refactor/</link><guid isPermaLink="false">66cf45432c0b3600013b7e01</guid><category><![CDATA[Quality]]></category><category><![CDATA[Refactoring]]></category><category><![CDATA[TDD]]></category><category><![CDATA[Testing]]></category><dc:creator><![CDATA[Johannes Steen]]></dc:creator><pubDate>Fri, 20 Oct 2023 10:19:42 GMT</pubDate><media:content url="https://ragingbit.github.io/content/images/2024/08/tempImagetsfn3q.gif" medium="image"/><content:encoded><![CDATA[<img src="https://ragingbit.github.io/content/images/2024/08/tempImagetsfn3q.gif" alt="Red, Green, Refactor"><p>There are numerous ways to maintain quality and correctness in the code we write - behaviour driven development, test driven development, fear driven development. The Red-Green-Refactor technique falls under TDD and is a way to ensure that the code we write is the result of the capabilities we ask of it while also fulfilling our standards of quality.</p><p>Using Red-Green-Refactor means that we start with a test that fails (Red), we then write the code that makes the test pass (Green) and last we improve the code for quality (Refactor). Then we repeat, and slowly build our code while ensuring it is tested. What follows is a convoluted example, but it demonstrates the process:</p><p>Red - write the test and enough code that it compiles.</p><figure class="kg-card kg-code-card"><pre><code class="language-cs">public record Fruit(string Name, string Colour, string Weight);

public record FruitEntity();

public class FruitService(Db db)
{
    public void Save(Fruit fruit)
    {
        throw new NotImplementedException();
    }
}

public void FruitService_should_save_fruit_to_db()
{
    var dbMock = Mock.Of&lt;Db&gt;();
    var service = new FruitService(dbMock);

    service.Save(new Fruit(&quot;apple&quot;, &quot;red&quot;, &quot;300g&quot;));

    dbMock.Verify(db =&gt; db.AddEntity(It.IsAny&lt;FruitEntity&gt;()), Times.Once);
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Just enough to compile and fail</span></p></figcaption></figure><p>Green - make the test pass by fulfilling the expectation in the test.</p><figure class="kg-card kg-code-card"><pre><code class="language-cs">public record FruitDto
{
    public FruitEntity(Fruit fruit)
    {
        Name = fruit.Name;
        Colour = fruit.Colour;
        Weight = fruit.Weight;
    }

    public string Name { get; }
    public string Colour { get; }
    public string Weight { get; }
}

public class FruitService(Db db)
{
    public void Save(Fruit fruit)
    {
        db.AddEntity(new FruitEntity(fruit));
    }
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Introduce some properties and a copy constructor, and use the injected Db service</span></p></figcaption></figure><p>Refactor - extract variables, clarify hidden logic, and other.</p><figure class="kg-card kg-code-card"><pre><code class="language-cs">public record FruitEntity
{
    public string Name { get; init; }
    public string Colour { get; init; }
    public string Weight { get; init; }
}

public class FruitService(Db db)
{
    public void Save(Fruit fruit)
    {
        var fruitEntity = new FruitEntity
        {
            Name = fruit.Name,
            Colour = fruit.Colour,
            Weight = fruit.Weight,
        };

        db.AddEntity(fruitEntity);
    }
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Move the initiation logic of the entity to the method - I like keeping my entities clean of logic</span></p></figcaption></figure><p> I&apos;ve encountered (and used) a fair few alternative techniques, such as Green-Red-Refactor (not a canonical name) where you start by writing the code and then you try to write a test that passes, realise you need to refactor the code to make it testable, and so on.</p><p>Doing strict TDD can be difficult and most end up using a process that falls somewhere between RGR and GRR - perhaps taking shortcuts by writing code that performs the task, compiles, but does nothing fancy like argument checking or validating input.</p><p>The end result of any testing is to ensure that our code does what we expect it to. How we arrive at that result is largely up to opinionated debate.</p>]]></content:encoded></item></channel></rss>
